==============
Version Constraints
==============

Terraform version constraints allow you to specify which versions of Terraform or provider plugins your configuration is compatible with. This ensures that your infrastructure code is used with the correct version of Terraform or providers, avoiding unexpected behavior due to version mismatches.

We can change the versions of hashicorp provider plugins

For Example:

Whenever we have new changes on AWS console the old code might not work so if you want to work with the new console or new features in AWS, we need to download the new provider plugins

https://registry.terraform.io/browse/providers  -- select AWS and show versions

when we do terraform init, It will download always latest, if you are using old version just use below code to update version

all version plugins will be under .terraform --> go inside

depend upon version, code will also change

vi main.tf


provider "aws" {

}

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "<5.56.1"   -- upgrade or downgrade, use > < >= <= anything is fine based on requriement

    }
  }
}

-- terraform init  [see it is downloading 5.56.1]

Now modify to latest <5.64.0

-- terraform init [it uses the old version only, if you want to upgrade use below command]

-- terraform init -upgrade   [see now latest plugins are downloaded]


========================
Upgrade local provider - check in chatgpt
========================

No Practise

vi main.tf

terraform {
  required_providers {
    myprovider = {
      source  = "local/myprovider"
      version = ">= 1.2.0"
    }
  }
}


Here, you're specifying that any version greater than or equal to 1.2.0 can be used.

-- terraform init -upgrade


=========================
TERRAFORM REFRESH - DANGER - Dont do this in Real time
==========================


In Terraform, the terraform refresh command is used to update the Terraform state file to reflect the current state of the real-world infrastructure.

This command queries the actual state of the resources defined in your Terraform configuration and compares it to the state recorded in the .tfstate file. If any discrepancies are found, the state file is updated to match the actual infrastructure.

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "one" {
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
  tags = {
    Name = "reyaz-server"
  }
}

-- terraform apply --auto-approve

-- cat terraform.tfstate   [This show reyaz-server]

Now change the value in AWS Console instance name to student-server

-- terraform apply --auto-approve  [TF will check the statefile first, in statefile it has reyaz-server, so TF will update AWS console
                                    to reyaz-server as there is difference between desired(tf) and actual state(AWS)]

See in AWS Console - changed to reyaz-server

Now change the value in AWS Console instance name to student-server

-- cat terraform.tfstate [This show reyaz-server]

-- terraform refresh

-- cat terraform.tfstate [This show student-server]

-- terraform destroy --auto-approve

===================
Terraform IMPORT  - track in TF which was not created by TF
===================

The terraform import command is used to bring existing infrastructure resources under Terraform management.

This is particularly useful when you have resources that were created manually or by another tool, and you now want to manage them using Terraform without recreating them.

Example 1:
---------

-- cat terraform.tfvars

Step 1: First launch a Linux or any EC2 instance manually on AWS Console

vi main.tf


provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "example" {
  ami           = "ami-08ee1453725d19cdb"  -- give the same ami of the EC2 to import
  instance_type = "t2.micro"
}

-- terraform import aws_instance.example i-0ab2056f11dfa5a6e

-- cat terraform.tfstate

-- terraform destroy --auto-approve


Example 2:
----------

vi main.tf

provider "aws" {
  region = "ap-south-1"
}

resource "aws_s3_bucket" "example" {
  bucket = "lala-ola-lelaa"
}

-- cat terraform.tfstate

-- terraform import aws_s3_bucket.example lala-ola-lelaa

-- cat terraform.tfstate

Example 3: - Multi resources import
-----------------------------------

-- terraform destroy --auto-approve

Again re-create resources in AWS Manually

vi main.tf


provider "aws" {
  region = "ap-south-1"
}

resource "aws_instance" "example" {
  ami           = "ami-08ee1453725d19cdb"
  instance_type = "t2.micro"
}
resource "aws_s3_bucket" "example" {
  bucket = "lala-ola-lelaa"
}


-- terraform import aws_instance.example i-0ab2056f11dfa5a6e

-- terraform import aws_s3_bucket.example lala-ola-lelaa

-- terraform destroy --auto-approve



Terraform does not support importing multiple resources in a single command or operation.

Each resource must be imported individually using the terraform import command. However, you can streamline the process by scripting the import commands, especially if you have a large number of resources to import

Terraform's import command works one resource at a time, so multiple resources need to be imported individually.

For Multiple resources import use another tool called TERRAFORMER





TERRAFORM MODULES:
===================


Terraform modules are a fundamental feature that helps in organizing and reusing Terraform configurations.

A module is a container for multiple resources that are used together.

Modules allow you to encapsulate and manage resources as a single unit, making your Terraform configurations more modular, readable, and maintainable.

Root Module:
-----------

    -- The root module is the main configuration where Terraform starts its execution.
    -- It is usually defined in the main configuration directory where terraform init and terraform apply are run.
    -- The root module can call other modules, referred to as child modules.

Child Modules:
--------------

    -- Child modules are modules that are called from within other modules (including the root module).
    -- They help in organizing resources and reusing configurations.
    -- Each child module can be stored in a separate directory and can be called using a module block in the root module or another parent module.

PROJECT:
--------

Create modules directory with instance, bucket, vpc.

├── main.tf
├── modules
│   ├── ec2-instances
│   │   ├── main.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   ├── s3-bucket
│   │   ├── main.tf
│   │   ├── outputs.tf
│   │   └── variables.tf
│   └── vpc
│       ├── main.tf
│       ├── outputs.tf
│       └── variables.tf
└── terraform.tfstate


-- yum install -y tree

-- mkdir -p modules/ec2-instances/

-- mkdir -p modules/s3-bucket/

-- mkdir -p modules/vpc/




-- cd modules/ec2-instances/
 
vi main.tf
vi outputs.tf
vi variables.tf

-- cd modules/s3-bucket/
 
vi main.tf
vi outputs.tf
vi variables.tf

-- cd modules/vpc/
 
vi main.tf
vi outputs.tf
vi variables.tf


Root Module main.tf

vi main.tf

git clone  https://github.com/ReyazShaik/terraform.git

cd modulesproject


-- tree

-- terraform init

-- terraform apply --auto-approve

-- terraform destroy --auto-approve

From <https://classroom.google.com/u/0/c/NzI3MTQ1MzU3NjIz> 

